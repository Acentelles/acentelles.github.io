<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>SuperSpartan by Hand | Alberto Centelles</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="SuperSpartan by Hand" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The goal of this article is to dive into the techniques behind the SuperSpartan’s polynomial IOP, which uses the sum-check protocol to prove CCS instances, by writing the protocol explicitely for a specific example. This is part 1 of a two-post series. These techniques used in SuperSpartan are at the core of the HyperNova protocol that will be explored in part 2." />
<meta property="og:description" content="The goal of this article is to dive into the techniques behind the SuperSpartan’s polynomial IOP, which uses the sum-check protocol to prove CCS instances, by writing the protocol explicitely for a specific example. This is part 1 of a two-post series. These techniques used in SuperSpartan are at the core of the HyperNova protocol that will be explored in part 2." />
<link rel="canonical" href="http://localhost:4000/cryptography/2024/08/05/superspartan-by-hand.html" />
<meta property="og:url" content="http://localhost:4000/cryptography/2024/08/05/superspartan-by-hand.html" />
<meta property="og:site_name" content="Alberto Centelles" />
<meta property="og:image" content="http://localhost:4000/media/super-spartan.jpeg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-08-05T00:00:00+01:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="http://localhost:4000/media/super-spartan.jpeg" />
<meta property="twitter:title" content="SuperSpartan by Hand" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-08-05T00:00:00+01:00","datePublished":"2024-08-05T00:00:00+01:00","description":"The goal of this article is to dive into the techniques behind the SuperSpartan’s polynomial IOP, which uses the sum-check protocol to prove CCS instances, by writing the protocol explicitely for a specific example. This is part 1 of a two-post series. These techniques used in SuperSpartan are at the core of the HyperNova protocol that will be explored in part 2.","headline":"SuperSpartan by Hand","image":"http://localhost:4000/media/super-spartan.jpeg","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/cryptography/2024/08/05/superspartan-by-hand.html"},"url":"http://localhost:4000/cryptography/2024/08/05/superspartan-by-hand.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Alberto Centelles" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Alberto Centelles</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">SuperSpartan by Hand</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-08-05T00:00:00+01:00" itemprop="datePublished">Aug 5, 2024
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <blockquote>
  <p><em>I’d like to thank Nicolas Mohnblatt for brainstorming, discussing and reviewing this article, and for his many shared insights. I’m also thankful to Srinath Setty, Jamie Gabbay and Apriori for their generous feedback.</em>
<em>This article wouldn’t have been possible without them. All mistakes are my own.</em></p>
</blockquote>

<p>This article was originally written on a SageMath Jupyter notebook, which can be found <a href="https://github.com/Acentelles/blogposts/tree/main/superspartan">here</a>.</p>

<h2 id="introduction">Introduction</h2>

<p>The <a href="https://dl.acm.org/doi/pdf/10.1145/146585.146605">sum-check protocol</a> is like one of those magic tricks that, despite having been exposed to how it works, it still makes your mind do some acrobatics every time you see it applied.</p>

<p>Any polynomial equation can be transformed into an instance of the sum-check, making this amazing algorithm surprisingly applicable.</p>

<p>Since the sum-check lies at the core of the <a href="https://eprint.iacr.org/2023/573.pdf">HyperNova</a>’s folding techniques, we will dive first into its details on a simpler case: the checking of a <a href="https://eprint.iacr.org/2023/552.pdf">Customisable Constraint System (CCS)</a> instance using the SuperSpartan’s polynomial IOP as described in their paper.</p>

<h2 id="transforming-any-check-into-a-sumcheck">Transforming any check into a sumcheck</h2>

<p>The goal of the sum-check is to check that an untrusted prover has computed the following equation correctly, where $f \in K[X_1,…,X_l]$ is a multivariate polynomial (not necessarily multilinear):</p>

<p>$\begin{aligned}
T &amp;= \sum_{x \in {0,1}^l} f(x) \ 
&amp;= \sum_{x_1 \in {0,1}} \sum_{x_2 \in {0,1}} … \sum_{x_l \in {0,1}} f(x_1, x_2, …, x_l)
\end{aligned}$</p>

<p>After $l$ rounds, the protocol allows the verifier to check $f(r_1,…,r_l) = c$, for some random $r_i \in \mathbb{F}$, which with high probability implies the original equation, due to the <a href="https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma">Schwartz-Zippel lemma</a>.</p>

<p>Say we have a polynomial $f$ encoding a vector of evaluations $v = [v_1,…, v_{n}]$ such that for all $x_i$ in some subdomain $H$, $f(x_i) = v_i$. In our setting, a prover wants to convince a verifier that this is the case (i.e. $\forall x_i \in H. f(x_i) = v_i$). If every $v_i = 0$, this is known as a zero-check.</p>

<p>Note that we can always transform the check $f(x_i) = v_i$ into a zero-check since $f(x_i) - v_i = 0$.</p>

<p>For example, in vanilla <a href="https://eprint.iacr.org/2019/953.pdf">Plonk</a>, $f$ is a univariate polynomial that encodes an execution trace and $H$ is a subset of the roots of unity of some prime field (e.g. $H := {\omega^1,\omega^2,\omega^3,\omega^4,\omega^5,\omega^6,\omega^7,\omega^8}$).</p>

<p>In <a href="https://eprint.iacr.org/2022/1355.pdf">HyperPlonk</a> (a variant of Plonk that transforms the zero-checks in the protocol into sumchecks), $H$ becomes a boolean hypercube ${0,1}^l$ (i.e. all the $l$ combinations of zeroes and ones), and $f$ a multivariate polynomial of some degree $d$ such that $\forall x \in {0,1}^l. f(x) = 0$.
For example, if $l$ is set to 3, then $H := {0,1}^3 = {(0,0,0), (0,0,1), (0,1,0), (0,1,1), (1,0,0), (1,0,1), (1,1,0), (1,1,1)}$</p>

<p><em>To apply the sum-check protocol, we need a statement of the form $\sum_{x\in {0,1}^l} f(x) = 0$</em>.</p>

<p>It is clear that if $\forall x\in {0,1}^l. f(x) = 0$ then $\sum_{x\in {0,1}^l} f(x) = 0$, but the converse doesn’t necessarily hold. For example, $f((0,0,1)) = -1$, $f((0,1,0)) = 1$ and $f(x) = 0$ otherwise makes $\sum_{x\in {0,1}^l} f(x) = 0$ but $f(x) \neq 0$ for some $x\in {0,1}^l$.</p>

<p>To overcome this, we define a different multilinear polynomial:</p>

<p>$
\begin{aligned}
\widetilde{eq} : &amp;\mathbb{F}^l \times \mathbb{F}^l \to \mathbb{F} \ 
&amp;(X_1, X_2) \mapsto 1, \text{ if } X_1 = X_2, X_1, X_2 \in {0,1}^l \ 
&amp;(X_1, X_2) \mapsto 0, \text{ if } X_1 \neq X_2, X_1, X_2 \in {0,1}^l
\end{aligned}
$</p>

<p>That is</p>

<p>$\widetilde{eq}(X_1, X_2) := \prod_{j=1}^l ((1-X_{1<em>j})(1-X</em>{2<em>j}) + X</em>{1<em>j} X</em>{2_j})$.</p>

<blockquote>
  <p>We use a tilde ~ over a function $g$ to emphasise that $\widetilde{g}$ is a multilinear polynomial.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">k</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">101</span><span class="p">)</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">"x1, x2, y1, y2, y3, x11, x22, y11, y22, y33"</span><span class="p">)</span>
<span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span> <span class="n">x11</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">y11</span><span class="p">,</span> <span class="n">y22</span><span class="p">,</span> <span class="n">y33</span> <span class="o">=</span> <span class="n">R</span><span class="p">.</span><span class="n">gens</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eqx</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x11</span><span class="p">)</span> <span class="o">+</span> <span class="n">x1</span><span class="o">*</span><span class="n">x11</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x22</span><span class="p">)</span> <span class="o">+</span> <span class="n">x2</span><span class="o">*</span><span class="n">x22</span><span class="p">)</span>
<span class="n">eqy</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y11</span><span class="p">)</span> <span class="o">+</span> <span class="n">y1</span><span class="o">*</span><span class="n">y11</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y22</span><span class="p">)</span> <span class="o">+</span> <span class="n">y2</span><span class="o">*</span><span class="n">y22</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y33</span><span class="p">)</span> <span class="o">+</span> <span class="n">y3</span><span class="o">*</span><span class="n">y33</span><span class="p">)</span>

<span class="n">eqx</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x11</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0
</code></pre></div></div>

<p><em>The new polynomial $\widetilde{eq}$ together with the sum-check protocol will allow us to compute the desired zero-check,</em> $\forall x \in H. f (x) = 0$, as follows:</p>

<p>We define a new polynomial</p>

<p>$\begin{aligned}
h : &amp;\mathbb{F}^l \to \mathbb{F} <br />
&amp; X \mapsto \sum_{x \in {0,1}^l} f(x) \cdot \widetilde{eq}(x, X)
\end{aligned}$</p>

<blockquote>
  <p>Note that $X$ is a variable while $x$ is not. $h$ is known as a multilinear extension of $f$ in the boolean hypercube, since $\forall X\in {0,1}^l. h(X) = f(X)$. That is, $f$ is defined over ${0,1}^l$ while $h$ is defined over $\mathbb{F}^l$.</p>
</blockquote>

<p>For example, if $X = (1,0,1)$, then $h((1,0,1)) = \sum_{x \in {0,1}^l} f(x) \cdot \widetilde{eq}(x, (1,0,1)) = f((1,0,1))$.</p>

<p>Since $\forall x\in {0,1}^l. f(x) = 0$, and $\forall X\in {0,1}^l. h(X)=f(X)$, then $\forall X\in {0,1}^l. h(X) = 0$.</p>

<p><em>The main difference between $f$ and $h$ is that $f$ is a *multivariate</em> polynomial of (potentially high) degree $d$, whereas $h$ is a multilinear polynomial.*</p>

<blockquote>
  <p>We know that a univariate polynomial $g$ of $k&gt;1$ coefficients in uniquely determined by $k$ evaluations, and it is of degree $k-1$. Similarly, a multilinear polynomial $h$ of $k$ variables is uniquely determined by $2^k$ evaluations.</p>
</blockquote>

<p>In this case, $h(Y) := \sum_{x \in {0,1}^l} f(x) \cdot \widetilde{eq}(x, Y)$ has $2^l$ coefficients (most of them zero) and so it is uniquely determined by $2^l$ evaluations. Since $\forall {0,1}^l. h(Y) = f(Y) = 0$, then $h$ is zero at $2^l$ points and must necessarily be the zero polynomial, $h = 0$.</p>

<p><strong>The verifier has reduced his task to checking that $h$ is indeed the zero polynomial, which is a simpler problem.</strong></p>

<p>By the Schwartz-Zippel lemma, we can verify that $h$ is the zero polynomial with high probability by evaluating $h$ at a random point $r \in \mathbb{F}^l$.</p>

<p>That is, $h(r) := \sum_{x \in {0,1}^l} f(x) \cdot \widetilde{eq}(x, r)$ must be equal to zero. Here is where we apply the sum-check protocol.</p>

<p>So <strong>if $h(r) = 0$, this implies with high probability that $h = 0$, which implies that $\forall Y \in {0,1}^l. h(Y) = 0$, which implies that $\forall x\in {0,1}^l. f(x) = 0$, thus proving the original statement with high probability (w.h.p.).</strong> In short,</p>

<p>$h(r) = 0 \overset{w.h.p}{\Longrightarrow} h = 0 \Longrightarrow \forall Y \in {0,1}^l . h(Y) = 0 \Longrightarrow \forall x\in {0,1}^l. f(x) = 0$.</p>

<h2 id="example-a-fibonacci-relation">Example: A Fibonacci relation</h2>

<p>The following recurrence relation is tailored to help us illustrate the workings sum-check protocol for CCS relations as is used in <a href="https://eprint.iacr.org/2023/573.pdf">HyperNova</a>. This example reflects the SuperSpartan’s polynomial IOP for CCS protocol described in the <a href="https://eprint.iacr.org/2023/552.pdf">CCS paper</a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// i-th iteration</span>
<span class="nf">fibonnaci</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">x_1</span><span class="p">,</span> <span class="n">y_2</span><span class="p">,</span> <span class="n">y_1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x_1</span> <span class="o">+</span> <span class="n">x_2</span> <span class="c1">// Fibonacci</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y_1</span> <span class="o">*</span> <span class="n">y_2</span> <span class="c1">// Multiplicative Fibonacci</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>     <span class="c1">// Fibonacci x (Multiplicative Fibonacci)</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>In the second part of this post, we will prove the result of iterating $n$ times over $f$, starting with some initial values, by applying the folding techniques in HyperNova.</p>
</blockquote>

<p>For now, we focus on proving a single iteration, in particular, that which results from the initial values $x_2 = 0, x_1 = 1, y_2=2, y_1=3$ that outputs $x = 1, y=6, t=6$.</p>

<p>So we first need to <em>arithmetise this statement</em>.</p>

<h3 id="a-ccs-primer">A CCS primer</h3>

<p><a href="https://eprint.iacr.org/2023/552.pdf">Customisable Constraint System (CCS)</a> relations are a generalisation of <a href="https://learn.0xparc.org/materials/circom/additional-learning-resources/r1cs%20explainer/">R1CS</a> relations.</p>

<p>In particular, a <em>relation</em> $\mathcal{R}$ in CCS is composed by:</p>

<ul>
  <li>a <em>structure</em> $s := ([M_1, …, M_t], [S_1,…,S_q], [c_1, …, c_q])$, plus some other bound parameters such as the number of rows $m$ and columns $n$ of the matrices $M_i$.</li>
  <li>an <em>instance</em>, which consists of public inputs $\times \in \mathbb{F}^l$ and private inputs $\omega \in \mathbb{F}^m$.</li>
</ul>

<p>that satisfies:</p>

<p>$\begin{aligned}   <br />
\sum_{i=0}^{q-1} c_i \cdot \circ_{j \in S_i} M_j \cdot z = \vec{0}
\end{aligned}$</p>

<p>where:</p>
<ul>
  <li>$z := (\omega, x, 1) \in \mathbb{F}^n$.</li>
  <li>$x \in \mathbb{F}^{l}$ are the public inputs.</li>
  <li>$\omega \in \mathbb{F}^{m - l - 1}$ are the private inputs.</li>
  <li>$M_j \cdot z$ denotes matrix-vector multiplication,</li>
  <li>$\circ$ denotes the Hadamard product between vectors</li>
  <li>$\vec 0$ is an $m$-sized vector with entries equal to the the additive identity $0 \in \mathbb{F}$.</li>
</ul>

<p>Expanded, a CCS equation looks like:</p>

<p>$\begin{aligned}   <br />
c_0 \cdot \overbrace{(M_{j_{0}} \cdot z \circ … \circ M_{j_{|{S_{0}}|-1}} \cdot z)}^{j_i \in S_0} + … + c_{q-1} \cdot \overbrace{(M_{j_{0}} \cdot z \circ … \circ M_{j_{|{S_{q-1}}|-1}} \cdot z)}^{j_i \in S_{q-1}} = \vec{0} 
\end{aligned}$.</p>

<p>In our case, $m = 4$ and $n = 8$ are the rows and columns of the $t=3$ matrices $M_1, M_2, M_3$.  ${M_1, M_2}$ are multiplied and added to ${M_3}$, so $S_1 = {1, 2}, S_2 = {3}$. Since there are two addends $S_1$ and $S_2$, $q =2$.</p>

<h3 id="a-fibonacci-ccs-relation">A Fibonacci CCS relation</h3>

<p>The Fibonacci combined recurrence relation of our example can easily be represented as a CCS relation:</p>

<p>$c_1 \cdot (M_1 \cdot z \circ M_2 \cdot z) + c_2 \cdot (M_3 \cdot z) = \vec{0}$</p>

<p>$\begin{aligned}<br />
&amp; \overbrace{1}^{c_1} \cdot (\overbrace{\begin{bmatrix} <br />
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \   0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \  \end{bmatrix}  }^{M_1} 
\overbrace{\begin{bmatrix} x_2 \ x_1 \ x \ y_2 \ y_1 \ y \ t \ 1 \end{bmatrix}}^z \circ
\overbrace{\begin{bmatrix}   0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \   0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \  \end{bmatrix}}^{M_2}<br />
\overbrace{\begin{bmatrix} x_2 \ x_1 \ x \ y_2 \ y_1 \ y \ t \ 1 \end{bmatrix}}^z) <br />
+&amp; \overbrace{(-1)}^{c_1} \cdot \overbrace{\begin{bmatrix}   0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \   0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \  \end{bmatrix}}^{M_3} 
\overbrace{\begin{bmatrix} x_2 \ x_1 \ x \ y_2 \ y_1 \ y \ t \ 1 \end{bmatrix}}^z
= \overbrace{\begin{bmatrix} 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \end{bmatrix}}^{\vec{0}}
\end{aligned}$</p>

<blockquote>
  <p>We have a particular interest in having our rows and columns of size $2^m$ for some $m$, since the sum-check protocol runs over the boolean hypercube. In this case, $m = 4 = 2^2$ is the number of constraints (i.e. rows) and $n = 8 = 2^3$ is the number of witnesses (i.e. columns) as well as the size of the vector $z$.</p>
</blockquote>

<blockquote>
  <p>Note that we have added a dummy row is $[0 ,…, 0]$ for $M_1, M_2, M_3$ (it could be any other vector as long as the CCS relation holds trivially).</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">M1</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">])</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">])</span>

<span class="n">M3</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">])</span>

<span class="c1"># First iteration
</span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">w</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">z1</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">w</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># CCS relation check
</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">M1</span><span class="o">*</span><span class="n">z1</span><span class="p">.</span><span class="n">column</span><span class="p">()).</span><span class="n">elementwise_product</span><span class="p">(</span><span class="n">M2</span><span class="o">*</span><span class="n">z1</span><span class="p">.</span><span class="n">column</span><span class="p">())</span><span class="o">-</span><span class="p">(</span><span class="n">M3</span><span class="o">*</span><span class="n">z1</span><span class="p">.</span><span class="n">column</span><span class="p">())</span> <span class="o">==</span> <span class="n">vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]).</span><span class="n">column</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span> <span class="o">=</span> <span class="n">M1</span><span class="p">.</span><span class="n">nrows</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">M1</span><span class="p">.</span><span class="n">ncols</span><span class="p">()</span>

<span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="transforming-ccs-relation-into-a-sum-check">Transforming CCS relation into a sum-check</h3>

<p>We want to turn this matrix-vector problem statement into a sum over the boolean hypercube.</p>

<p>We begin by creating multilinear extensions $\widetilde{M_i}$ of $M_i$ and $\widetilde{z}$ of $z$ such that the multilinear polynomial</p>

<p>$\begin{aligned}
f_i : \mathbb{F}^{\log m} &amp;\to \mathbb{F} <br />
X &amp;\mapsto \sum_{y \in {0, 1 }^{\log n}} \widetilde{M_i}(X, y) \cdot \widetilde{z}(y)
\end{aligned}$</p>

<p>is a multilinear extension of our matrix-vector product $M_i \cdot z$.</p>

<p>Since $m=2^2$ and $n=8 = 2^3$, then $\log m = 2$, $\log n = 3$, and</p>

<p>$\begin{aligned}
f_i : \mathbb{F}^2 &amp;\to \mathbb{F} <br />
(X_1, X_2) &amp;\mapsto \sum_{y_1 \in {0, 1 }}\sum_{y_2 \in {0, 1 }}\sum_{y_3 \in {0, 1 }} \widetilde{M_i}((X_1, X_2), (y_1, y_2, y_3)) \cdot \widetilde{z}(y_1, y_2, y_3)
\end{aligned}$.</p>

<blockquote>
  <p>Note that a matrix $M$ can be seen as a function $M : {0,1}^{\log m} \times {0,1}^{\log n} \to \mathbb{F}$, since for each row $m_i$ and column $n_j$ we can derive the element $M(m_i, n_j)$ from the matrix $M$. 
As in the HyperNova paper, we will denote $s = \log m$ and $s’ = \log n$.</p>
</blockquote>

<p>The multilinear extensions $\widetilde{M_i}$ of $M_i$ and $\widetilde{z}$ of $z$ are defined as</p>

<p>$\begin{aligned}
\widetilde{M_i}(X, Y) &amp;:= \sum_{x \in {0, 1 }^{s}} \sum_{y \in {0, 1 }^{s’}} M_i(x, y) \cdot \widetilde{eq}(x, X) \cdot \widetilde{eq}(y, Y)
\end{aligned}$</p>

<p>$\widetilde{z}(Y) := \sum_{y \in {0, 1 }^{s’}} z(y) \cdot \widetilde{eq}(y, Y)$.</p>

<p>Setting $s= \log m = \log 4 = 2, s’= \log n = \log 8 = 3$ as in our example:</p>

\[\begin{aligned}
\widetilde{M_i}((X_1, X_2), (Y_1, Y_2, Y_3)) := &amp;\sum_{x_1 \in \{0, 1 \}}\sum_{x_2 \in \{0, 1 \}} \\
&amp; \sum_{y_1 \in \{0, 1 \}} \sum_{y_2 \in \{0, 1 \}} \sum_{y_3 \in \{0, 1 \}} M_i((x_1, x_2), (y_1, y_2, y_3)) \cdot \widetilde{eq}((x_1, x_2), (X_1, X_2)) \cdot \widetilde{eq}((y_1, y_2, y_3), (Y_1, Y_2, Y_3))
\end{aligned}\]

\[\widetilde{z}((Y_1, Y_2, Y_3)) := \sum_{y_1 \in \{0, 1 \}}\sum_{y_2 \in \{0, 1 \}}\sum_{y_3 \in \{0, 1 \}} z((y_1, y_2, y_3)) \cdot \widetilde{eq}((y_1, y_2, y_3), (Y_1, Y_2, Y_3))\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From-binary-to-decimal polynomials
</span><span class="n">row</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x2</span>
<span class="n">col</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">y3</span>

<span class="k">def</span> <span class="nf">Mi_linear</span><span class="p">(</span><span class="n">Mi</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span>
            <span class="nb">sum</span><span class="p">([</span>
                <span class="nb">sum</span><span class="p">([</span>
                    <span class="nb">sum</span><span class="p">([</span>
                        <span class="nb">sum</span><span class="p">([</span>
                            <span class="n">Mi</span><span class="p">[</span><span class="n">Integer</span><span class="p">(</span><span class="n">row</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="n">x2</span><span class="p">))][</span><span class="n">Integer</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="n">y1</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y3</span><span class="o">=</span><span class="n">y3</span><span class="p">))]</span> <span class="o">*</span> <span class="n">eqx</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span><span class="n">x11</span><span class="o">=</span><span class="n">x11</span><span class="p">,</span><span class="n">x22</span><span class="o">=</span><span class="n">x22</span><span class="p">)</span> <span class="o">*</span> <span class="n">eqy</span><span class="p">(</span><span class="n">y1</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">y11</span><span class="p">,</span> <span class="n">y2</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span> <span class="n">y22</span><span class="o">=</span><span class="n">y22</span><span class="p">,</span> <span class="n">y3</span><span class="o">=</span><span class="n">y3</span><span class="p">,</span> <span class="n">y33</span><span class="o">=</span><span class="n">y33</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">y3</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="k">for</span> <span class="n">y2</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">y1</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">x2</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
         <span class="k">for</span> <span class="n">x1</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">z_linear</span><span class="p">(</span><span class="n">zi</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span>
                <span class="nb">sum</span><span class="p">([</span>
                    <span class="nb">sum</span><span class="p">([</span>
                        <span class="n">zi</span><span class="p">[</span><span class="n">Integer</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="n">y1</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y3</span><span class="o">=</span><span class="n">y3</span><span class="p">))]</span><span class="o">*</span> <span class="n">eqy</span><span class="p">(</span><span class="n">y1</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">y11</span><span class="p">,</span> <span class="n">y2</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span> <span class="n">y22</span><span class="o">=</span><span class="n">y22</span><span class="p">,</span> <span class="n">y3</span><span class="o">=</span><span class="n">y3</span><span class="p">,</span> <span class="n">y33</span><span class="o">=</span><span class="n">y33</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">y3</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">y2</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">y1</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
</code></pre></div></div>

<p>Thus the multilinear extension $f_i$ of our matrix-vector product $M \cdot z$ is</p>

<p>$
f_i((X_1, X_2)) = \sum_{y \in {0, 1 }^3} \widetilde{M_i}((X_1, X_2), y) \cdot \widetilde{z}(y)
$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Mi_z_prod</span><span class="p">(</span><span class="n">Mi</span><span class="p">,</span> <span class="n">zi</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span>
                <span class="nb">sum</span><span class="p">([</span>
                    <span class="nb">sum</span><span class="p">([</span>
                        <span class="n">Mi_linear</span><span class="p">(</span><span class="n">Mi</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">zi</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">y3</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">y2</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">y1</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
</code></pre></div></div>

<p>The CCS relation we want to check,</p>

<p>$1 \cdot (M_1 \cdot z \circ M_2 \cdot z) + (-1) \cdot (M_3 \cdot z) = \vec{0}$</p>

<p>is thus turned into a polynomial equation</p>

<p>$\begin{aligned}
G((X_1, X_2)) := &amp; 1 \cdot (\sum_{y \in {0, 1 }^3} \widetilde{M_1}((X_1, X_2), y) \cdot \widetilde{z}(y) \cdot \sum_{y \in {0, 1 }^{3}} \widetilde{M_1}((X_1, X_2), y) \cdot \widetilde{z}(y)) \  + &amp; (-1) \cdot (\sum_{y \in {0, 1 }^{3}} \widetilde{M_3}((X_1, X_2), y) \cdot \widetilde{z}(y)) = 0
\end{aligned}$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">G</span> <span class="o">=</span> <span class="n">Mi_z_prod</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Mi_z_prod</span><span class="p">(</span><span class="n">M2</span><span class="p">,</span> <span class="n">z1</span><span class="p">)</span> <span class="o">-</span> <span class="n">Mi_z_prod</span><span class="p">(</span><span class="n">M3</span><span class="p">,</span> <span class="n">z1</span><span class="p">)</span>
<span class="n">G</span>
</code></pre></div></div>

<!-- <span style="background-color:green">
    21*x11^2*x22^2 - 17*x11^2*x22 - 15*x11*x22^2 + 2*x11^2 + 11*x11*x22 - 2*x11
</span> -->

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>21*x11^2*x22^2 - 17*x11^2*x22 - 15*x11*x22^2 + 2*x11^2 + 11*x11*x22 - 2*x11
</code></pre></div></div>

<p>The prover wants to prove that $G((x_1, x_2)) = 0$ for all $x_1, x_2 \in {0,1}$ using the sum-check.</p>

<p>That is $G((0,0))= G((0,1))= G((1,0))= G((1,1))=0$.</p>

<p>As expected, we extend the multivariate polynomial $G : {0,1} \times {0,1} \to \mathbb{F}$ of degree $2$ into a multilinear polynomial</p>

<p>$\begin{aligned}
h : \mathbb{F} \times \mathbb{F} &amp;\to \mathbb{F} <br />
((X_1, X_2)) &amp;\mapsto \sum_{x_1 \in {0,1}}\sum_{x_2 \in {0,1}} G((x_1, x_2)) \cdot \widetilde{eq}((X_1, X_2), (x_1, x_2)) <br />
&amp;=  G((0, 0)) \cdot \widetilde{eq}((X_1, X_2), (0, 0)) <br />
&amp;+ G((0, 1)) \cdot \widetilde{eq}((X_1, X_2), (0, 1)) <br />
&amp;+ G((1, 0)) \cdot \widetilde{eq}((X_1, X_2), (1, 0)) <br />
&amp;+ G((1,1)) \cdot \widetilde{eq}((X_1, X_2), (1, 1)) <br />
&amp;= 0
\end{aligned}$</p>

<p>As we did earlier, now $h(X)$ is a multilinear extension that encodes the $4$ evaluations (${(0,0), (0,1), (1,0), (1,1) }$) of $G$ into its coefficients, so it is uniquely determined by $4$ evaluations (i.e. a polynomial of $n$ coefficients is of degree $n - 1$, thus uniquely defined by $n$ evaluations).</p>

<p>Since $\forall x_1, x_2 \in {0,1}. h((x_1, x_2)) = G((x_1, x_2)) = 0$, then $h$ must necessarily be the zero polynomial $h = 0$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">h</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span>
        <span class="nb">sum</span><span class="p">([</span>
            <span class="n">G</span><span class="p">(</span><span class="n">x11</span><span class="o">=</span><span class="n">x11</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span><span class="n">x22</span><span class="p">)</span> <span class="o">*</span> <span class="n">eqx</span><span class="p">(</span><span class="n">x11</span><span class="o">=</span><span class="n">x11</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span><span class="n">x22</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x22</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
     <span class="k">for</span> <span class="n">x11</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

<span class="n">h</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0
</code></pre></div></div>

<blockquote>
  <p>Note that there would be no harm in doing such transformation if $G$ were already multilinear.
If a polynomial $G \in \mathbb{F}[x_1,…, x_s]$ is multilinear, then $G(X) = \sum_{x\in {0,1}^s} G(x) \cdot \widetilde{eq}(x, X)$
You can check lemma 6 of HyperNova for a proof.</p>
</blockquote>

<p>By the Schwartz-Zippel lemma, we can evaluate</p>

<p>$h((X_1, X_2)) = \sum_{x_1 \in {0,1}}\sum_{x_2 \in {0,1}}  G((x_1, x_2)) \cdot \widetilde{eq}((X_1, X_2), (x_1, x_2)) = 0$</p>

<p>at a random point $\beta := (\beta_1, \beta_2) \in \mathbb{F}^2$ to prove that $h$ is indeed the zero polynomial.</p>

<p>That is, if</p>

<p>$\begin{aligned}
h((\beta_1, \beta_2)) &amp;= \sum_{x_1 \in {0,1}}\sum_{x_2 \in {0,1}}  G((x_1, x_2)) \cdot \widetilde{eq}((\beta_1, \beta_1), (x_1, x_2)) <br />
&amp;= G((0, 0)) \cdot \widetilde{eq}((\beta_1, \beta_2), (0, 0)) <br />
&amp;+ G((0, 1)) \cdot \widetilde{eq}((\beta_1, \beta_2), (0, 1)) <br />
&amp;+ G((1, 0)) \cdot \widetilde{eq}((\beta_1, \beta_2), (1, 0)) <br />
&amp;+ G((1,1)) \cdot \widetilde{eq}((\beta_1, \beta_2), (1, 1)) <br />
&amp;= 0
\end{aligned}$</p>

<p>then $h(X_1, X_2) = 0$ with high probability.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">beta1</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="n">beta2</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">random_element</span><span class="p">()</span>

<span class="p">(</span><span class="n">beta1</span><span class="p">,</span> <span class="n">beta2</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(57, 23)
</code></pre></div></div>

<blockquote>
  <p>Note that $\widetilde{eq}((\beta_1, \beta_2), (x_1, x_2)) = ((1-\beta_1)(1-x_1) + \beta_1 x_1) \cdot ((1-\beta_2)(1-x_2) + \beta_2 x_2)$ may not be zero if $\beta_1, \beta_2 \notin {0,1}$.</p>
</blockquote>

<p>Let $Q(X_1, X_2) := G((X_1, X_2)) \cdot \widetilde{eq}((\beta_1, \beta_2), (X_1, X_2))$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Q</span> <span class="o">=</span> <span class="n">G</span> <span class="o">*</span> <span class="n">eqx</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="n">beta1</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="n">beta2</span><span class="p">)</span>
<span class="n">Q</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>28*x11^3*x22^3 + 22*x11^3*x22^2 - 16*x11^2*x22^3 + 13*x11^3*x22 + 34*x11^2*x22^2 + 26*x11*x22^3 - 23*x11^3 + 29*x11^2*x22 - 43*x11*x22^2 - 38*x11^2 + 8*x11*x22 - 40*x11
</code></pre></div></div>

<blockquote>
  <p>To help us refer to the different sum-checks conceptually, we give them different names:</p>
  <ul>
    <li><strong>Outer sum-check</strong>: $0 = G(x)$ for all $x \in {0,1}^2$.</li>
    <li><strong>Inner sum-check</strong>: $T_j = \sum_{y\in {0,1}^{3}} \widetilde{M}_j(r,y) \cdot \widetilde{z}(y)$</li>
  </ul>
</blockquote>

<h3 id="outer-sum-check">Outer sum-check</h3>

<p>The prover engages with the verifier in the following sum-check:</p>

<p>$\sum_{x_1 \in {0,1}}\sum_{x_2 \in {0,1}} Q(x_1, x_2) = 0$</p>

<p>which implies that $G((x_1, x_2)) = 0$ for all $x_1, x_2 \in {0,1}$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sum</span><span class="p">([</span> 
    <span class="nb">sum</span><span class="p">([</span> <span class="n">Q</span><span class="p">(</span><span class="n">x11</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span><span class="n">x2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x2</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="k">for</span> <span class="n">x1</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
</code></pre></div></div>

<h4 id="round-1">Round 1</h4>

<p>The prover $P$ sends the verifier $V$ a univariate polynomial $s_1(X_1)$ claiming to be equal to $Q_1(X_1) := \sum_{x_2 \in {0,1}} Q(X_1, x_2)$. That is, we keep the first variable unbound while summing up the values over the boolean hypercube.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Q1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span> <span class="n">Q</span><span class="p">(</span><span class="n">x22</span><span class="o">=</span><span class="n">x2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x2</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">Q1</span>

<span class="n">s1</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>17*x11^3 - 29*x11^2 + 12*x11
</code></pre></div></div>

<p>The verifier first checks that $s_1(0) + s_1(1)$ matches the expected result, i.e. $s_1(0) + s_1(1) = 0$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s1</span><span class="p">(</span><span class="n">x11</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">s1</span><span class="p">(</span><span class="n">x11</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
</code></pre></div></div>

<p>Then the verifier checks $s_1 = Q_1$ by checking that $Q_1$ and $s_1$ agree at a random point $r_1$ (Schwartz-Zippel lemma).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r1</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="n">r1</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>84
</code></pre></div></div>

<p>The verifier can compute directly $s_1(r_1)$ but doesn’t know what $Q_1$ is, so the check $s_1 = Q_1$ must be done recursively.</p>

<h4 id="round-2">Round 2</h4>

<p>The new claim is that $s_1(r_1) := \sum_{x_2 \in {0,1}} Q(r_1, x_2)$, so $P$ sends $V$ a univariate $s_2(X_2)$ which he claims to be equal to  $Q_2(X_2) := Q(r_1, X_2)$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Q2</span> <span class="o">=</span> <span class="n">Q</span><span class="p">(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">Q2</span>

<span class="n">s2</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-18*x22^3 + 37*x22^2 + 27*x22 - 20
</code></pre></div></div>

<p>The verifier first checks that $s_1(r_1)$ is indeed $s_2(0) + s_2(1)$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s2</span><span class="p">(</span><span class="n">x22</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">s2</span><span class="p">(</span><span class="n">x22</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">s1</span><span class="p">(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
</code></pre></div></div>

<p>Then the verifier sends a random challenge $r_2$ to check that $s_2(r_2) = Q_2(r_2)$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r2</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="n">r2</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>31
</code></pre></div></div>

<p>There is no more need for recursion, since the verifier can now evaluate</p>

<p>$\begin{aligned}
Q_2(r_2) = Q((r_1, r_2)) =&amp; \widetilde{eq}((\beta_1, \beta_2), (r_1, r_2)) \cdot G((r_1, r_2)) <br />
=&amp; \widetilde{eq}((\beta_1, \beta_2), (r_1, r_2)) \cdot ((\sum_{y \in {0, 1 }^3} \widetilde{M_1}((r_1, r_2), y) \cdot \widetilde{z}(y) \cdot \sum_{y \in {0, 1 }^{3}} \widetilde{M_1}((r_1, r_2), y) \cdot \widetilde{z}(y)) \  - &amp; \sum_{y \in {0, 1 }^{3}} \widetilde{M_3}((r_1, r_2), y) \cdot \widetilde{z}(y))
\end{aligned}$</p>

<p>However, the verifier doesn’t want to compute the inner sums</p>

<p>$\sum_{y \in {0, 1 }^3} \widetilde{M_i}((r_1, r_2), y) \cdot \widetilde{z}(y)$</p>

<p>for $i \in {1,2,3}$ by himself, so he engages in further sum-checks with the prover.</p>

<h3 id="batching-inner-sum-checks">Batching inner sum-checks</h3>

<p>The prover is asked to compute the inner sum-checks</p>

<p>$\begin{aligned}
T_i &amp;= \sum_{y \in {0, 1 }^3} \widetilde{M_i}((r_1, r_2), y) \cdot \widetilde{z}(y) <br />
&amp;= \sum_{y_1 \in {0, 1 }} \sum_{y_2 \in {0, 1 }} \sum_{y_3 \in {0, 1 }} \widetilde{M_i}((r_1, r_2), (y_1, y_2, y_3)) \cdot \widetilde{z}((y_1, y_2, y_3)) <br />
\end{aligned}$</p>

<p>and to send $T_i$ to the verifier for $i \in {1,2,3}$ to sum-check it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Ti_generator</span><span class="p">(</span><span class="n">Mi</span><span class="p">,</span> <span class="n">zi</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span>
        <span class="nb">sum</span><span class="p">([</span>
            <span class="nb">sum</span><span class="p">([</span>
                <span class="n">Mi_linear</span><span class="p">(</span><span class="n">Mi</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">zi</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">y3</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">y2</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">for</span> <span class="n">y1</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>

<span class="n">T1</span> <span class="o">=</span> <span class="n">Ti_generator</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">z1</span><span class="p">)</span>
<span class="n">T2</span> <span class="o">=</span> <span class="n">Ti_generator</span><span class="p">(</span><span class="n">M2</span><span class="p">,</span> <span class="n">z1</span><span class="p">)</span>
<span class="n">T3</span> <span class="o">=</span> <span class="n">Ti_generator</span><span class="p">(</span><span class="n">M3</span><span class="p">,</span> <span class="n">z1</span><span class="p">)</span>
<span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(33, -10, 10)
</code></pre></div></div>

<p>However, instead of engaging in separate sum-checks $T_i = \sum_{y \in {0, 1 }^3} \widetilde{M_i}((r_1, r_2), y) \cdot \widetilde{z}(y)$ for each $i \in {1,2,3}$, the prover will batch them using a random element $\alpha$ generated by the verifier.</p>

<p>$\begin{aligned}
T_1 + \alpha \cdot T_2 + \alpha^2 \cdot T_3 =&amp; \sum_{y \in {0, 1 }^3} \widetilde{M_1}((r_1, r_2), y) \cdot \widetilde{z}(y) \ 
+&amp; \alpha \cdot \sum_{y \in {0, 1 }^3} \widetilde{M_2}((r_1, r_2), y) \cdot \widetilde{z}(y) <br />
+&amp; \alpha^2 \cdot \sum_{y \in {0, 1 }^3} \widetilde{M_3}((r_1, r_2), y) \cdot \widetilde{z}(y) <br />
=&amp; \sum_{y \in {0, 1 }^3} (\widetilde{M_1}((r_1, r_2), y) + \alpha \cdot \widetilde{M_2}((r_1, r_2), y) <br />
+&amp; \alpha^2 \cdot \widetilde{M_3}((r_1, r_2), y)) \cdot \widetilde{z}(y)
\end{aligned}$</p>

<p>Which proves with high probability that all $T_1, T_2, T_3$ are correctly computed from $\sum_{y \in {0, 1 }^3} \widetilde{M_i}((r_1, r_2), y) \cdot \widetilde{z}(y)$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alpha</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="n">alpha</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>78
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span> <span class="o">=</span> <span class="n">T1</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">T2</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">T3</span>
<span class="n">T</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-2
</code></pre></div></div>

<h4 id="round-1-1">Round 1</h4>

<p>The prover $P$ sends the verifier $V$ a univariate polynomial $q_1(Y_1)$ to be equal to</p>

<p>$\begin{aligned}
f_1(Y_1) &amp;:= \sum_{y_2 \in {0,1}}\sum_{y_3 \in {0,1}} (\widetilde{M_1}((r_1, r_2), (Y_1, y_2, y_3)) <br />
&amp; \quad \quad \quad \quad \quad \quad \quad + \alpha \cdot \widetilde{M_2}((r_1, r_2), (Y_1, y_2, y_3)) <br />
&amp; \quad \quad \quad \quad \quad \quad \quad + \alpha^2 \cdot  \widetilde{M_3}((r_1, r_2), (Y_1, y_2, y_3))) \cdot \widetilde{z}((Y_1, y_2, y_3)) <br />
\end{aligned}$</p>

<p>That is, we keep the first variable unbound while summing up the values over the boolean hypercube.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span>
        <span class="nb">sum</span><span class="p">([</span>
            <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M1</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y22</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y22</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">+</span> 
            <span class="n">alpha</span> <span class="o">*</span> <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M2</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y22</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y22</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">alpha</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M3</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y22</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y22</span><span class="o">=</span><span class="n">y2</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">y3</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">for</span> <span class="n">y2</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">q1</span> <span class="o">=</span> <span class="n">f1</span>

<span class="n">q1</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-2*y11^2 + 16*y11 - 8
</code></pre></div></div>

<p>The verifier first checks that $q_1(0) + q_1(1)$ matches the expected result, i.e. $q_1(0) + q_1(1) = T$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q1</span><span class="p">(</span><span class="n">y11</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">q1</span><span class="p">(</span><span class="n">y11</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">T</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
</code></pre></div></div>

<p>Then the verifier checks $q_1 = f_1$ by checking that $f_1$ and $q_1$ agree at a random point $r’_1$ (Schwartz-Zippel lemma).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r11</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="n">r11</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>23
</code></pre></div></div>

<p>The verifier can compute directly $q_1(r’_1)$ but doesn’t know what $f_1$ is, so the check $q_1 = f_1$ must be done recursively.</p>

<h4 id="round-2-1">Round 2</h4>

<p>The new claim is that</p>

<p>$\begin{aligned}
q_1(r’<em>1) &amp;= \sum</em>{y_2 \in {0,1}}\sum_{y_3 \in {0,1}} (\widetilde{M_1}((r_1, r_2), (r’_1, y_2, y_3))  <br />
&amp; \quad \quad \quad \quad \quad \quad + \alpha \cdot \widetilde{M_2}((r_1, r_2), (r’_1, y_2, y_3)) <br />
&amp; \quad \quad \quad \quad \quad \quad + \alpha^2 \cdot \widetilde{M_3}((r_1, r_2), (r’_1, y_2, y_3))) \cdot \widetilde{z}((r’_1, y_2, y_3)) <br />
\end{aligned}$</p>

<p>so $P$ sends $V$ a univariate $q_2(Y_2)$ claimed to be equal to</p>

<p>$\begin{aligned}
f_2(Y_2) &amp;:= \sum_{y_3 \in {0,1}} (\widetilde{M_1}((r_1, r_2), (r’_1, Y_2, y_3)) <br />
&amp; \quad \quad \quad \quad + \alpha \cdot  \widetilde{M_2}((r_1, r_2), (r’_1, Y_2, y_3))  <br />
&amp; \quad \quad \quad \quad + \alpha^2 \cdot \widetilde{M_3}((r_1, r_2), (r’_1, Y_2, y_3))) \cdot \widetilde{z}((r’_1, Y_2, y_3)) <br />
\end{aligned}$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span>
        <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M1</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span> <span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">+</span> 
        <span class="n">alpha</span> <span class="o">*</span> <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M2</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">+</span>
        <span class="n">alpha</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M3</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">y3</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">y3</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">q2</span> <span class="o">=</span> <span class="n">f2</span>

<span class="n">q2</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>27*y22^2 + 9*y22 + 37
</code></pre></div></div>

<p>The verifier first checks that $q_1(r’_1)$ is indeed $q_2(0) + q_2(1)$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q2</span><span class="p">(</span><span class="n">y22</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">q2</span><span class="p">(</span><span class="n">y22</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">q1</span><span class="p">(</span><span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
</code></pre></div></div>

<p>Then sends a random challenge $r’_2$ to check that $q_2(r’_2) = f_2(r’_2)$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r22</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="n">r22</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>96
</code></pre></div></div>

<h4 id="round-3">Round 3</h4>

<p>Finally, the prover claims that</p>

<p>$\begin{aligned}
q_2(r’<em>2) &amp;= \sum</em>{y_3 \in {0,1}} (\widetilde{M_1}((r_1, r_2), (r’_1, r’_2, y_3))  <br />
&amp; \quad \quad \quad \quad + \alpha \cdot \widetilde{M_2}((r_1, r_2), (r’_1, r’_2, y_3))  <br />
&amp; \quad \quad \quad \quad + \alpha^2 \cdot \widetilde{M_3}((r_1, r_2), (r’_1, r’_2, y_3))) \cdot \widetilde{z}((r’_1, r’_2, y_3)) <br />
\end{aligned}$</p>

<p>so $P$ sends $V$ a univariate $q_3(Y_2)$ claimed to be equal to</p>

<p>$\begin{aligned}
f_3(Y_3) &amp;:= (\widetilde{M_1}((r_1, r_2), (r’_1, r’_2, Y_3)) <br />
&amp;+ \alpha \cdot \widetilde{M_2}((r_1, r_2), (r’_1, r’_2, Y_3))  <br />
&amp;+ \alpha^2 \cdot \widetilde{M_3}((r_1, r_2), (r’_1, r’_2, Y_3))) \cdot \widetilde{z}((r’_1, r’_2, Y_3)) <br />
\end{aligned}$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f3</span> <span class="o">=</span> <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M1</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span> <span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">)</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M2</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">)</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M3</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">)</span>

<span class="n">q3</span> <span class="o">=</span> <span class="n">f3</span>

<span class="n">q3</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-45*y33^2 - 33*y33 + 19
</code></pre></div></div>

<p>The verifier first checks that $q_2(r’_2)$ is indeed $q_3(0) + q_3(1)$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q3</span><span class="p">(</span><span class="n">y33</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">q3</span><span class="p">(</span><span class="n">y33</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">q2</span><span class="p">(</span><span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
</code></pre></div></div>

<p>Then, using a random value $r’_3$, he can compute on his own $f_3(r’_3)$ and check that $q_3(r’_3)$ is indeed equal to $f_3(r’_3)$, thus $q_3 = f_3$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r33</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="n">r33</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>84
</code></pre></div></div>

<p>That is, that $f_3(r’_3) = \widetilde{M_i}((r_1, r_2), (r’_1, r’_2, r’_3)) \cdot \widetilde{z}((r’_1, r’_2, r’_3))$, which the verifier can easily compute.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c1</span> <span class="o">=</span> <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M1</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span> <span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">r33</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">r33</span><span class="p">)</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M2</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">r33</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">r33</span><span class="p">)</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Mi_linear</span><span class="p">(</span><span class="n">M3</span><span class="p">)(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span> <span class="n">r2</span><span class="p">,</span> <span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">r33</span><span class="p">)</span> <span class="o">*</span> <span class="n">z_linear</span><span class="p">(</span><span class="n">z1</span><span class="p">)(</span><span class="n">y11</span><span class="o">=</span><span class="n">r11</span><span class="p">,</span><span class="n">y22</span><span class="o">=</span><span class="n">r22</span><span class="p">,</span><span class="n">y33</span><span class="o">=</span><span class="n">r33</span><span class="p">)</span>

<span class="n">c1</span> <span class="o">==</span> <span class="n">q3</span><span class="p">(</span><span class="n">y33</span><span class="o">=</span><span class="n">r33</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
</code></pre></div></div>

<p>Thus, the verifier has checked that</p>

<p>$\begin{aligned}
T_1 + \alpha \cdot T_2 + \alpha^2 \cdot T_3 =&amp; \sum_{y \in {0, 1 }^3} \widetilde{M_1}((r_1, r_2), y) \cdot \widetilde{z}(y) \ 
+&amp; \alpha \cdot \sum_{y \in {0, 1 }^3} \widetilde{M_2}((r_1, r_2), y) \cdot \widetilde{z}(y) <br />
+&amp; \alpha^2 \cdot \sum_{y \in {0, 1 }^3} \widetilde{M_3}((r_1, r_2), y) \cdot \widetilde{z}(y)
\end{aligned}$</p>

<p>so he can trust that all $T_1, T_2, T_3$ derive from $\sum_{y \in {0, 1 }^3} \widetilde{M_i}((r_1, r_2), y) \cdot \widetilde{z}(y)$, and use them in the remaining step of the outer sum-check.</p>

<h3 id="final-check">Final check</h3>

<p>We were left in the outer sum-check with the verifier wanting to compute</p>

<p>$\begin{aligned}
s_2(r_2) = Q_2(r_2) =&amp; Q((r_1, r_2)) <br />
=&amp; \widetilde{eq}((\beta_1, \beta_2), (r_1, r_2)) \cdot G((r_1, r_2)) <br />
=&amp; \widetilde{eq}((\beta_1, \beta_2), (r_1, r_2)) <br />
\cdot &amp; ((\sum_{y \in {0, 1 }^3} \widetilde{M_1}((r_1, r_2), y) \cdot \widetilde{z}(y) \cdot \sum_{y \in {0, 1 }^{3}} \widetilde{M_1}((r_1, r_2), y) \cdot \widetilde{z}(y)) \  - &amp; \sum_{y \in {0, 1 }^{3}} \widetilde{M_3}((r_1, r_2), y) \cdot \widetilde{z}(y))
\end{aligned}$</p>

<p>However, he needed help from the prover to compute</p>

<p>$T_i := \sum_{y \in {0, 1 }^3} \widetilde{M_i}((r_1, r_2), y) \cdot \widetilde{z}(y)$</p>

<p>After batching the inner sum-checks into a single grand inner sum-check, the verifier has now proof of $T_1, T_2$ and $T_3$, so can easily compute</p>

<p>$\begin{aligned}
Q((r_1, r_2)) =&amp; \widetilde{eq}((\beta_1, \beta_2), (r_1, r_2)) \cdot G((r_1, r_2)) <br />
=&amp; \widetilde{eq}((\beta_1, \beta_2), (r_1, r_2)) <br />
&amp;\cdot ((\sum_{y \in {0, 1 }^3} \widetilde{M_1}((r_1, r_2), y) \cdot \widetilde{z}(y) \cdot \sum_{y \in {0, 1 }^{3}} \widetilde{M_1}((r_1, r_2), y) \cdot \widetilde{z}(y)) <br />
&amp;- \sum_{y \in {0, 1 }^{3}} \widetilde{M_3}((r_1, r_2), y) \cdot \widetilde{z}(y)) <br />
=&amp; \widetilde{eq}((\beta_1, \beta_2), (r_1, r_2)) \cdot (T_1 \cdot T_2 - T_3)
\end{aligned}$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Q</span><span class="p">(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span><span class="n">r2</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">T1</span> <span class="o">*</span> <span class="n">T2</span> <span class="o">-</span> <span class="n">T3</span><span class="p">)</span> <span class="o">*</span> <span class="n">eqx</span><span class="p">(</span><span class="n">x11</span><span class="o">=</span><span class="n">r1</span><span class="p">,</span> <span class="n">x22</span><span class="o">=</span><span class="n">r2</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="n">beta1</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="n">beta2</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
</code></pre></div></div>

<p>Which proves the original claim that the CCS relation for the Fibonacci example $1 \cdot (M_1 \cdot z \circ M_2 \cdot z) + (-1) \cdot (M_3 \cdot z) = \vec{0}$ holds.</p>

<p>That is,</p>

<p>$\begin{aligned}
Q((r_1, r_2)) &amp;= \widetilde{eq}((\beta_1, \beta_2), (r_1, r_2)) \cdot (T_1 \cdot T_2 - T_3) <br />
&amp;\overset{w.h.p}{\Longrightarrow} \sum_{x_1 \in {0,1}}\sum_{x_2 \in {0,1}} Q(x_1, x_2) = 0 <br />
&amp;\Longrightarrow \forall x_1, x_2 \in {0,1}. G((x_1, x_2)) = 0 <br />
&amp;\Longrightarrow 1 \cdot (M_1 \cdot z \circ M_2 \cdot z) + (-1) \cdot (M_3 \cdot z) = \vec{0}
\end{aligned}$</p>

<blockquote>
  <p>There are two ways in which a verifier may evaluate these multi-linear extension of CCS matrices:</p>
  <ol>
    <li>if matrices are <em>structured</em> the verifier evaluates them in logarithmic time</li>
    <li>if matrices are <em>unstructured</em>, the prover can prove evaluations of MLE of sparse matrices in linear time using memory checking techniques (see Spark compiler in the <a href="https://eprint.iacr.org/2019/550.pdf">Spartan paper</a>).</li>
  </ol>
</blockquote>

<h3 id="conclusion">Conclusion</h3>

<p>We made it! To recap, we have shown in this article how:</p>

<p><strong>1.</strong> Any polynomial equation can be transformed into a (bunch of) sum-checks, by leveraging the properties of multilinear polynomials and the Schwartz-Zippel lemma.</p>

<p><strong>2.</strong> A CCS relation can be transformed into a sum of a multilinear polynomial over the boolean hypercube and proved using the sum-check protocol.</p>

<p>During the outer sum-check
$\sum_{x_1 \in {0,1}}\sum_{x_2 \in {0,1}} Q(x_1, x_2) = 0$ the verifier was eventually be confronted to compute $Q(r)$ for some $r \in \mathbb{F}^{2}$.</p>

<p>Since $Q(r) = G(r) \cdot \widetilde{eq}((\beta_1, \beta_2), r)$ the verifier had to compute $\sum_{y\in {0,1}^{3}} \widetilde{M}_j(r,y) \cdot \widetilde{z}(y)$ for $j \in {1,2,3}$. Thus he asked for help to the prover, and engaged in a batched inner sum-check.</p>

<p><strong>The main idea of HyperNova will be to fold or delay the computation of any inner sum-check</strong>. This will be explored in the next article.</p>

<p>Thanks for reading!</p>

  </div><a class="u-url" href="/cryptography/2024/08/05/superspartan-by-hand.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Alberto Centelles</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Alberto Centelles</li><li><a class="u-email" href="mailto:centelles.alberto@gmail.com">centelles.alberto@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
